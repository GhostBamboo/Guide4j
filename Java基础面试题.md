### abstract class 和 interface 有什么区别?

声明方法的存在而不去实现它的类叫抽象类。

- 不能创建抽象类的实例；
- 可以创建一个变量，其类型是一个抽象类，并让他指向具体子类的一个实例；
- 不能有抽象构造函数或抽象静态方法。 

接口是抽象类的变体。

- 接口中所有方法都是抽象的；
- 多继承性可通过实现这样的接口而获得；
- 接口只可以定义 static final 成员变量。

### String、StringBuilder、StringBuffer的区别

- String 是不可变的对象，每次对 String 类型进行改变的时候其实是产生了一个新的 String 对象，然后指针指向新的 String 对象； 
- StringBuffer 是线程安全的可变字符序列，需要同步，则使用。 
- StringBuilder 线程不安全，速度更快，单线程使用。 

String 是一个类，但却是不可变的，所以 String 创建的算是一个字符串常量， StringBuffer 和 StringBuilder 都是可变的。所以每次修改 String 对象的值都是新建一个对象再指向这个对象。而使用 StringBuffer 则是对 StringBuffer 对象本身进行 

操作。所以在字符串经常改变的情况下，使用 StringBuffer 要快得多。



### 数据连接池的工作机制

J2EE 服务器启动时会建立一定数量的池连接，并一直维持不少于此数目的池连接。客户端程序需要连接时，池驱动程序会返回一个未使用的池连接并将其表记为忙。如果当前没有空闲连接，池驱动程序就新建一定数量的连接，新建连接的数量有配置参数决定。当使用的池连接调用完成后，池驱动程序将此连接表记为空闲，其他调用就可以使用这个连接。

### JDBC中的 **PreparedStatement** 、 Statement、CallableStatement 

预编译语句java.sql.PreparedStatement ,扩展自Statement,不但具有Statement的所有能 力而且具有更强大的功能。不同的是，PreparedStatement 是在创建语句对象的同时给出要 执行的sql 语句。这样，sql 语句就会被系统进行预编译，执行的速度会有所增加，尤其是在执行大语句的时候，效果更加理想。CallableStatement 执行存储过程，预编译的，带参数的。

### **ClassLoader** **的分类及加载顺序**

主要分4类，见下图：

- JVM类加载器：这个模式会加载JAVA_HOME/lib下的jar包 ；
- 扩展类加载器：会加载JAVA_HOME/lib/ext下的jar包 ；
- 系统类加载器：这个会去加载指定了classpath参数指定的jar 文件 ；
- 用户自定义类加载器：sun提供的ClassLoader是可以被继承 的，允许用户自己实现类加载器 。

类加载器的加载顺序如图所示：

![](<http://39.96.187.148:8080/externalLinksController/downloadFileByKey/ClassLoader加载顺序.png?dkey=cb6a844e-88fb-4161-aa26-21943adfc44f>)

JVM并不是把所有的类一次性全部加载到JVM中的，也不是每次用到一个类的时候都去查找，对于JVM级别的类加载器在启 动时就会把默认的JAVA_HOME/lib里的class文件加载到JVM 中，因为这些是系统常用的类，对于其他的第三方类，则采用用到时就去找，找到了就缓存起来的，下次再用到这个类的时 候就可以直接用缓存起来的类对象了，ClassLoader之间也是有父子关系的，每个ClassLoader都有一个父ClassLoader,在加载类 时ClassLoader与其父ClassLoader的查找顺序如下图所示：

![](<http://39.96.187.148:8080/externalLinksController/downloadFileByKey/ClassLoader查找顺序.png?dkey=04793c11-9a89-4422-9694-5a84545d7d68>)

### TCP的优势

从传输数据来讲，TCP/UDP以及其他协议都可以完成数据的传输，从一端传输到另外一端，TCP比较出众的一点就是提供一个**可靠** 的，**流控**的数据传输，所以实现起来要比其他协议复杂的多，先来看下这两个修饰词的意义： 

1. Reliability ，提供TCP的可靠性，TCP的传输要保证数据能够准确到达目的地，如果不能，需要能检测出来并且重新发送数据。 

2. Data Flow Control，提供TCP的**流控**特性，管理发送数据的速 率，不要超过设备的承载能力 。

为了能够实现以上2点，TCP实现了很多细节的功能来保证数据传输，比如说 滑动窗口适应系统，超时重传机制，累计ACK等。

### 三次握手、四次挥手

##### 三次握手：

在基于 TCP 通信中，双方要进行通信，则需要建立一个物理连接，建立 时需要双方进行三次握手，成功即可完成连接建立。 

**原因**： 

```
在网络通信中，网络存在拥塞，发送的报文可能会由于网络拥塞的原因，导致对方收不到。若采用直接开启连接，当客户端发送连接建立请求后，不等待确认服务器可以打开连接就直接打开连接，这样如果服务器收不到报文，根本不知道客户端，那么客户端的打开的物理连接是无效的，但客户端不知道， 还一直发送数据，做无用的工作。
```

**过程：**

![](<http://39.96.187.148:8080/externalLinksController/downloadFileByKey/TCP三次握手.png?dkey=613e1c67-4ada-4b83-a838-84538a542a72>)

##### 四次挥手：

当双方通信结束时，需要四次挥手来关闭连接。

**原因：**

```
TCP 连接是双向的，一个是从客户端到服务端，另一个是从服务端到客户端。假设当前客户端已经发送完所有数据到服务 器，则此时可以告知服务器，我已经发送完数据了，可以关闭我这端到另一端的通道，服务器收到关闭报文则可发送一个确认，确认关闭；但此时由于服务器可能还需要发送数据到客户端，因此并不会关闭从服务端到客户端方向的通道；等服务端发完了，才发送一个 FIN 报文给客户端，客户端收到之后发送确认，则此时 TCP 连接才正式关闭。
```

**过程：**

![](<http://39.96.187.148:8080/externalLinksController/downloadFileByKey/TCP四次挥手.png?dkey=6f17d439-7e77-43c6-8a97-611cb08c2ee0>)

**TIME_WAIT 状态：**

```
从四次挥手过程可以看到，当服务器像客户端发送 FIN 报文后，客户端响应确认报文时，客户端处于 TIME_WAIT 状态，而不是处于 CLOSE 状态。之所以会这样主要是因为客户端发送确认报文后，不能立刻关闭连接。因为如果服务端收不到确认报文，会将 FIN 报文重传，但此时客户端已经关闭连接了，这样会导致客户端收不到，而服务端则一直苦苦等待客户端发送确认报文，不断重传 FIN 报文。因此客户端在响应确认报文后，需要等待两个报文往返时间，以此来确保服务端能够正常收到确认报文关闭连接。
```

### HTTPS是如何解决通信安全问题的？

HTTPS 要使客户端与服务器端的通信过程得到安全保证，必须 使用的对称加密算法，但是协商对称加密算法的过程，需要使用非对称加密算法来保证安全，然而直接使用非对称加密的过程本身也不安全，会有中间人篡改公钥的可能性，所以客户端与服务器不直接使用公钥，而是使用数字证书签发机构颁发的证书来保证非对称加密过程本身的安全。这样通过这些机制协商出一个对称加密算法，就此双方使用该算法进行加密解密。从而解决了客户端与服务 器端之间的通信安全问题。